<head>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="../css/my.css"/>
</head>

<h3 text-align="center">103. Binary Tree Zigzag Level Order Traversal</h3>
<p>Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree [3,9,20,null,null,15,7],</p>
&nbsp;&nbsp; &nbsp;   3</br>
&nbsp;&nbsp;&nbsp;   / \</br>
&nbsp;&nbsp;  9 &nbsp; 20</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;  \</br>
&nbsp;&nbsp;&nbsp;   15&nbsp;&nbsp;&nbsp;   7</br>
return its zigzag level order traversal as:</br>
[</br>
&nbsp;&nbsp;  [3],</br>
&nbsp;&nbsp;  [20,9],</br>
&nbsp;&nbsp;  [15,7]</br>
]</br>
<hr>
approach 1:
<pre>

class Solution {
public:
    vector&ltvector&ltint>> res;
    vector&ltvector&ltint>> zigzagLevelOrder(TreeNode* root) {
        zigzagLevelOrder(root, 0);
        return res;
    }

    void zigzagLevelOrder(TreeNode* root, int height){
        if(root == NULL) return;
        if(res.size() &lt= height) res.resize(height+1);
        
        if(height%2 == 0) res[height].push_back(root->val);
        else res[height].insert(res[height].begin(), root->val);
        
        zigzagLevelOrder(root->left, height+1);
        zigzagLevelOrder(root->right, height+1);
    }
};
</pre><br/>
<hr>
approach 2:<br/>
<pre>
class Solution{
public:
    vector&ltvector&ltint>> zigzagLevelOrder(TreeNode* root){
        vector&ltvector&ltint>> res;
        if(root == NULL) return res;
        queue&ltTreeNode*> q;
        bool left2right = true;
        q.push(root);

        while(!q.empty()){
            int qsize = q.size();
            vector&ltint> tem(qsize);
            for(int i = 0; i&lt qsize; ++i){
                TreeNode* cur = q.front();
                q.pop();
                int index = left2right ? i : qsize - i - 1;
                tem[index] = cur->val;
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);

            }
            left2right = !left2right;
            res.push_back(tem);
        }
        return res;
    }
}
</pre>